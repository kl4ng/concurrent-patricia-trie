\documentclass[conference]{IEEEtran}

\usepackage{cite}


%\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/


%\usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/


\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{Concurrent Patricia Trie}

\author{\IEEEauthorblockN{Cole Garner}
\IEEEauthorblockA{School of Electrical Engineering and Computer Science\\
University of Central Florida\\
Orlando, Florida 32816\\
Email: ColeGarner@knights.ucf.edu}
\and
\IEEEauthorblockN{Kevin Lang}
\IEEEauthorblockA{School of Electrical Engineering and Computer Science\\
University of Central Florida\\
Orlando, Florida 32816\\
Email: klang2012@gmail.com}}

\maketitle


\begin{abstract}
This paper shows an implementation of a non-blocking Patricia Trie that combines techniques found in numerous recent implementations. It heavily uses the Compare and Swap operation and uses flags to prevent blocking. Additionally, it implements the flags in multiple locations in order to both increase efficiency and reduce the amount of conflicts. It also uses Rust and more efficient memory managment and decreased overhead to improve upon its predecessors. 
\end{abstract}


\section{Introduction}
A Patricia Trie, also known as a Radix tree, is a unique version of a regular tree. The defining feature of any trie, also knownas a digital tree, is that the position of a node in a tree defines the key for that node. A Patricia trie takes this and optimizes the tree by merging any parent node with only one child in order to save space and create a more efficient tree.\cite{Shafiei2013} Because a Patricia Trie is a relatively simple data structure and has many practical uses, it is a good data structure to have an efficient parallelization technique for. 
\par
Our implementation of a parallelized, lock-free Patricia Tree will aim to maximize performance and space-efficiency while removing some of the overhead of previous implementations by fine-tuning the memory managment. We will combining multiple older approaches and taking the benefits of each and combining them. Our implementation will be focused on using compare-and-swap (CAS) operations which will allow for a blocking-free implementation. \cite{Shafiei2013,Brown2014}
\par
The main changes in our implementation from previous ones is that we will be storing the flags in multiple locations to allow for a smaller portion of the tree to be blocked off for some operations, creating less conflicts overall and increasing performance. \cite{Natarajan2014} The other main improvement we will be making is decreasing the overhead of creating and removing flags by compacting their size as much as possible, and more efficiently handling garbage collection . 
\par
Another large difference in our implementation is that we will be using a newer language called Rust and making use of it's unique advantages to help create our more efficient implementation. One benefit Rust offers is that it has an efficient memory-safety property without using garbage collection. However, the largest benefit for our implementation is their unique approach to concurrency using their ownership model that ensures more than one thread can not attempt to write to the same location at the same time. However, just because our specific implementation is in rust does not mean that other languages can not implement the techniques used here.
\par
For the actual Patricia tree algorithm we will be using an algorithm similar to the psuedo-code seen in \cite{Shafiei2013}. However, we will be inserting various improvements on this algorithm, with the main one being that flags will also appear in the edges between two nodes to decrease conflicts. \cite{Natarajan2014}


\section{Related Works}
Creating high-performance, non-blocking data structures has advanced in recent years. There is work into making generalized data structures using CAS operations. \cite{Brown2013} This work has further been expanded into making generalized techniques for non-blocking trees. \cite{Brown2014} These techniques revolve around using load-link extended (LLX), store-conditional extended (SCX) and validate-extended (VLX) primitives which are generalized techniques of the standard, non-extended versions of the primitives. \cite{Brown2013, Brown2014} The techniques used are very powerful and efficient and help form a basis for some techniques used in our work. 
\par
Earlier, non-generalized implementation of this technique was seen in a few different data structures. The one related to our work is Shafiei's implementation of non-blocking Patricia Tries. \cite{Shafiei2013} This implementation used a binary tree implementation and handled the paralleziation by creating flag objects for operations that keep track of what has to be changed. These flags are very powerful because they let multiple threads work on one operation so one thread is not forced to wait.  Additionally, since the flag is there there is no chance of a portion of the tree becoming unusable if one thread fails in the middle of an operation. \cite{Shafiei2013, Howley2012} This technique is similar to ours, except we will be eliminating some of the overhead in their implementation due to the large amount of flags they created and the large size of each. Additionally we will be aiming to improve to memory management as compared to it. 
\par
Another similar work is an implementation of a lock-free binary search tree by Natarajan and Mittal. Their work also heavily involves CAS operations but the largest difference is that instead of marking the nodes they mark the edges between the nodes.\cite{Natarajan2014} This has interesting applications in that it allows a smaller portion of the tree to be flagged during insert and delete operations and allows for less conflicts on the whole.
\par
Shun and Blelloch showed another alternative approach to parallelization of trees with a multiway Cartesian tree. Theres is slightly unique in that they first create an array and then convert it into a tree. However, despite being different from out project, the algorithims they show in order to generate the tree from the array using parallization techniques warranted study. We looked into their techniques of differentiating what part a particular node is protected in, but ultimately decided the techniques were too far from our own to be much use. \cite{Shun2014}

\section{Rust Language}
Describe it here in detail, especially the parts of the std lib that we are using extensively.


\section{Algorithm Description}
Go into detail about what changes (if any) we make from the original pseudocode due to the nature of the Rust language (for better or for worse). Go into detail about what we do new (hopefully able to implement it with >2 children, or have less Flag objects).


\section{Conclusion}
The conclusion goes here.


\section{Acknowledgment}
Acknowledge orignial paper author here once he (hopefully) provides source code and any other patricia trie implementations we test against for empirical evaluation.


% appendix section for midterm report
\appendix
\subsection{Challenges}
Talk about rust-lang and its difficulties, mainly. Some overlap with Rust Language section expected.


\subsection{Completed Tasks}
Decent chunk of original algorithm done. Research complete. Source code links to other implementations we can compare against. 


\subsection{Remaining Tasks}
Optimize code once completed, then attempt to modify algorithm to be extended to >2 children OR use less memory.
Also need to run performance comparisons and get source code from others.


% references section
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,references}


\end{document}


%\subsection{Subsection Heading Here}
%Subsection text here.


%\subsubsection{Subsubsection Heading Here}
%Subsubsection text here.
